{
  "name": "Categorize Transaction",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "categorize-transaction",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-categorize",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        250,
        300
      ],
      "webhookId": "categorize-transaction"
    },
    {
      "parameters": {
        "jsCode": "// Normalize merchant/description for matching\n// Handle webhook data - it may be in body or at root level\nconst webhookData = $input.item.json.body || $input.item.json;\nconst description = webhookData.description || '';\nconst merchant = webhookData.merchant || '';\nconst user_id = webhookData.user_id || '';\nconst type = webhookData.type || '';\nconst amount = webhookData.amount || 0;\nconst date = webhookData.date || '';\nconst transaction_id = webhookData.transaction_id || '';\n\n// Normalize: uppercase, remove special chars\nconst normalize = (str) => {\n  if (!str) return '';\n  return str\n    .toUpperCase()\n    .replace(/[^A-Z0-9\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst normalizedMerchant = normalize(merchant);\nconst normalizedDescription = normalize(description);\nconst pattern = normalizedMerchant || normalizedDescription;\n\n// Return all fields needed for downstream nodes\nreturn {\n  user_id: user_id,\n  description: description,\n  merchant: merchant,\n  type: type,\n  amount: amount,\n  date: date,\n  transaction_id: transaction_id,\n  pattern: pattern,\n  normalized_merchant: normalizedMerchant,\n  normalized_description: normalizedDescription\n};"
      },
      "id": "normalize-pattern",
      "name": "Normalize Pattern",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Check Learned Mapping - Make HTTP request while preserving input\nconst input = $input.item.json;\n\n// Preserve all original input fields\nconst originalData = {\n  user_id: input.user_id || '',\n  description: input.description || '',\n  merchant: input.merchant || '',\n  type: input.type || '',\n  amount: input.amount || 0,\n  date: input.date || '',\n  transaction_id: input.transaction_id || '',\n  pattern: input.pattern || '',\n  normalized_merchant: input.normalized_merchant || '',\n  normalized_description: input.normalized_description || ''\n};\n\n// Prepare request body for Firebase function\nconst requestBody = {\n  data: {\n    user_id: originalData.user_id,\n    pattern: originalData.pattern,\n    transaction_type: originalData.type\n  }\n};\n\n// Make HTTP request to Firebase function using N8N's HTTP helper\nconst FIREBASE_URL = 'https://us-central1-money-magnet-cf5a4.cloudfunctions.net/checkCategoryMappingHttp';\n\ntry {\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: FIREBASE_URL,\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: requestBody,\n    json: true\n  });\n  \n  // Handle Firebase callable function response wrapper\n  const httpResponse = response;\n  const result = httpResponse.result || httpResponse;\n  \n  // Extract mapping data\n  const mapping_found = result.mapping_found || false;\n  const category_id = result.category_id || null;\n  const category_name = result.category_name || null;\n  const confidence = result.confidence || 1.0;\n  \n  // Return all original fields plus mapping response\n  return {\n    ...originalData,\n    mapping_found: mapping_found,\n    category_id: category_id,\n    category_name: category_name,\n    confidence: confidence,\n    source: mapping_found ? 'learned' : null\n  };\n} catch (error) {\n  // If request fails, return original data with mapping_found = false\n  console.error('Error checking category mapping:', error.message);\n  return {\n    ...originalData,\n    mapping_found: false,\n    category_id: null,\n    category_name: null,\n    confidence: 0.5,\n    source: null\n  };\n}"
      },
      "id": "check-mapping",
      "name": "Check Learned Mapping",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "mapping-found",
              "leftValue": "={{ $json.mapping_found }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-mapping",
      "name": "Mapping Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        850,
        300
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "category-id",
              "name": "category_id",
              "value": "={{ $json.category_id }}",
              "type": "string"
            },
            {
              "id": "category-name",
              "name": "category_name",
              "value": "={{ $json.category_name }}",
              "type": "string"
            },
            {
              "id": "confidence",
              "name": "confidence",
              "value": "={{ $json.confidence || 1.0 }}",
              "type": "number"
            },
            {
              "id": "source",
              "name": "source",
              "value": "learned",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "use-learned",
      "name": "Use Learned Category",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.2,
      "position": [
        1050,
        200
      ]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced similarity-based categorization using USER'S ACTUAL CATEGORIES\n// This code maps keywords to the user's actual category names\n// Preserve all input data\nconst input = $input.item.json;\nconst description = input.description || '';\nconst merchant = input.merchant || '';\nconst normalizedMerchant = input.normalized_merchant || '';\nconst normalizedDescription = input.normalized_description || '';\nconst user_id = input.user_id || '';\nconst type = input.type || 'expense';\n\n// Get user's categories from previous node\nconst userCategories = input.categories || [];\n\n// Filter categories by type (expense/income)\nconst filteredCategories = userCategories.filter(cat => cat.type === type);\n\n// Use normalized text for better matching (already uppercase, no special chars)\n// Fall back to lowercase original if normalized not available\nconst text = ((normalizedMerchant || merchant.toLowerCase()) + ' ' + (normalizedDescription || description.toLowerCase())).trim();\n\n// Normalize function for keywords (remove special chars, lowercase)\nfunction normalizeKeyword(str) {\n  return str.toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\n// Calculate similarity between two strings (Levenshtein-based)\n// Only returns high scores for meaningful matches\nfunction similarity(str1, str2) {\n  const longer = str1.length > str2.length ? str1 : str2;\n  const shorter = str1.length > str2.length ? str2 : str1;\n  if (longer.length === 0) return 0;\n  if (shorter.length < 3) return 0; // Ignore very short matches\n  \n  // Check for exact match (normalized)\n  if (longer === shorter) return 1.0;\n  \n  // Check for meaningful substring match (shorter must be at least 4 chars)\n  if (shorter.length >= 4 && longer.includes(shorter)) return 0.9;\n  if (longer.length >= 4 && shorter.includes(longer)) return 0.9;\n  \n  // Calculate edit distance for similarity\n  const editDistance = levenshteinDistance(longer, shorter);\n  const similarityScore = (longer.length - editDistance) / longer.length;\n  \n  // Only return similarity if it's meaningful (>= 0.6)\n  return similarityScore >= 0.6 ? similarityScore : 0;\n}\n\n// Levenshtein distance calculation\nfunction levenshteinDistance(str1, str2) {\n  const matrix = [];\n  for (let i = 0; i <= str2.length; i++) {\n    matrix[i] = [i];\n  }\n  for (let j = 0; j <= str1.length; j++) {\n    matrix[0][j] = j;\n  }\n  for (let i = 1; i <= str2.length; i++) {\n    for (let j = 1; j <= str1.length; j++) {\n      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1,\n          matrix[i][j - 1] + 1,\n          matrix[i - 1][j] + 1\n        );\n      }\n    }\n  }\n  return matrix[str2.length][str1.length];\n}\n\n// Find best matching keyword with similarity score\n// Prioritizes exact matches, then substring, then similarity\nfunction findBestMatch(text, keywords) {\n  let bestMatch = null;\n  let bestScore = 0;\n  \n  // Normalize text for comparison\n  const textNormalized = normalizeKeyword(text);\n  const textWords = textNormalized.split(/\\s+/).filter(w => w.length >= 3);\n  \n  for (const keyword of keywords) {\n    const keywordNormalized = normalizeKeyword(keyword);\n    \n    // Priority 1: Exact match (normalized)\n    if (textNormalized === keywordNormalized) {\n      return { keyword, score: 1.0 };\n    }\n    \n    // Priority 2: Exact substring match (keyword appears in text)\n    if (textNormalized.includes(keywordNormalized) && keywordNormalized.length >= 4) {\n      return { keyword, score: 1.0 };\n    }\n    \n    // Priority 3: Word-by-word exact match\n    for (const word of textWords) {\n      if (word === keywordNormalized) {\n        return { keyword, score: 1.0 };\n      }\n      if (keywordNormalized.includes(word) && word.length >= 4) {\n        return { keyword, score: 0.95 };\n      }\n    }\n    \n    // Priority 4: Similarity matching (only if no exact match found)\n    if (bestScore < 0.95) {\n      // Check word-by-word similarity\n      for (const word of textWords) {\n        const sim = similarity(word, keywordNormalized);\n        if (sim > bestScore && sim >= 0.6) { // Minimum threshold\n          bestScore = sim;\n          bestMatch = keyword;\n        }\n      }\n      \n      // Check full text similarity\n      const fullSim = similarity(textNormalized, keywordNormalized);\n      if (fullSim > bestScore && fullSim >= 0.6) { // Minimum threshold\n        bestScore = fullSim;\n        bestMatch = keyword;\n      }\n    }\n  }\n  \n  // Only return if we have a meaningful match (score >= 0.6)\n  return (bestMatch && bestScore >= 0.6) ? { keyword: bestMatch, score: bestScore } : null;\n}\n\n// Keyword mapping to category name patterns (maps to user's category names)\n// This maps common keywords to category name patterns that we'll match against user categories\nconst keywordToCategoryPattern = {\n  // Food & Dining\n  'groceries': ['grocery', 'groceries', 'supermarket', 'food store', 'market'],\n  'restaurants': ['restaurant', 'restaurants', 'dining', 'diner', 'fast food', 'fastfood'],\n  'coffee': ['coffee', 'cafe', 'espresso', 'latte'],\n  \n  // Transportation\n  'gas': ['gas', 'fuel', 'gasoline', 'petrol', 'gas station'],\n  'transportation': ['transportation', 'transit', 'uber', 'lyft', 'taxi', 'parking'],\n  \n  // Home & Utilities\n  'utilities': ['utility', 'utilities', 'electric', 'water', 'internet', 'phone', 'cable'],\n  'rent': ['rent', 'rental', 'apartment', 'housing', 'lease'],\n  \n  // Shopping & Entertainment\n  'shopping': ['shopping', 'retail', 'store', 'amazon', 'online'],\n  'entertainment': ['entertainment', 'movie', 'theater', 'music', 'game', 'streaming'],\n  \n  // Health & Personal\n  'healthcare': ['healthcare', 'health care', 'medical', 'doctor', 'pharmacy', 'hospital'],\n  'personal care': ['personal care', 'haircut', 'salon', 'spa', 'gym', 'fitness'],\n  \n  // Other\n  'subscriptions': ['subscription', 'membership', 'netflix', 'spotify', 'premium'],\n  'insurance': ['insurance', 'policy', 'coverage'],\n  'education': ['education', 'tuition', 'school', 'university', 'college'],\n  'travel': ['travel', 'hotel', 'flight', 'airline', 'vacation'],\n  'charity & donations': ['donation', 'charity', 'nonprofit'],\n  'fees & charges': ['fee', 'charge', 'penalty', 'interest'],\n  'income': ['salary', 'paycheck', 'wage', 'income', 'bonus', 'dividend']\n};\n\n// Build keyword arrays for each category pattern\nconst categoryKeywords = {};\nfor (const [pattern, keywords] of Object.entries(keywordToCategoryPattern)) {\n  categoryKeywords[pattern] = keywords;\n}\n\n// Now map keywords to user's actual category names\n// For each user category, find matching keyword patterns\nlet bestCategoryMatch = null;\nlet bestCategoryScore = 0;\nlet bestMatchedKeyword = null;\n\nfor (const userCategory of filteredCategories) {\n  const categoryName = (userCategory.name || '').toLowerCase().trim();\n  \n  // Try to match category name against keyword patterns\n  for (const [pattern, keywords] of Object.entries(keywordToCategoryPattern)) {\n    // Check if category name matches pattern\n    const patternMatch = keywords.some(kw => {\n      const kwLower = kw.toLowerCase();\n      return categoryName.includes(kwLower) || kwLower.includes(categoryName);\n    });\n    \n    if (patternMatch) {\n      // Now check if transaction text matches keywords for this pattern\n      const match = findBestMatch(text, keywords);\n      if (match && match.score > bestCategoryScore) {\n        bestCategoryScore = match.score;\n        bestCategoryMatch = userCategory;\n        bestMatchedKeyword = match.keyword;\n      }\n    }\n  }\n  \n  // Also try direct matching: check if transaction text contains category name\n  const categoryNameMatch = findBestMatch(text, [categoryName]);\n  if (categoryNameMatch && categoryNameMatch.score > bestCategoryScore) {\n    bestCategoryScore = categoryNameMatch.score;\n    bestCategoryMatch = userCategory;\n    bestMatchedKeyword = categoryNameMatch.keyword;\n  }\n}\n\n// Set confidence based on similarity score\nlet confidence = 0.6;\nif (bestCategoryScore >= 0.9) {\n  confidence = 0.95; // Very high confidence for exact/close matches\n} else if (bestCategoryScore >= 0.7) {\n  confidence = 0.85; // High confidence for good matches\n} else if (bestCategoryScore >= 0.5) {\n  confidence = 0.75; // Medium confidence for partial matches\n} else if (bestCategoryScore > 0) {\n  confidence = 0.65; // Low confidence for weak matches\n}\n\n// Return all original fields plus AI categorization results\n// Return the user's actual category_id and category_name if match found\nreturn {\n  ...input,\n  user_id: user_id,\n  type: type,\n  description: description,\n  merchant: merchant,\n  suggested_category: bestCategoryMatch ? bestCategoryMatch.name : null,\n  category_id: bestCategoryMatch ? bestCategoryMatch.id : null,\n  category_name: bestCategoryMatch ? bestCategoryMatch.name : null,\n  confidence: bestCategoryMatch ? confidence : 0.5,\n  source: bestCategoryMatch ? 'ai' : null,\n  match_score: bestCategoryScore,\n  matched_keyword: bestMatchedKeyword\n};\n\n"
      },
      "id": "ai-categorize",
      "name": "AI Categorization",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1050,
        400
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Get User Categories - Make HTTP request while preserving input\nconst input = $input.item.json;\n\n// Preserve all original input fields\nconst originalData = {\n  user_id: input.user_id || '',\n  description: input.description || '',\n  merchant: input.merchant || '',\n  type: input.type || 'expense',\n  amount: input.amount || 0,\n  date: input.date || '',\n  transaction_id: input.transaction_id || '',\n  pattern: input.pattern || '',\n  normalized_merchant: input.normalized_merchant || '',\n  normalized_description: input.normalized_description || '',\n  mapping_found: input.mapping_found || false,\n  category_id: input.category_id || null,\n  category_name: input.category_name || null,\n  confidence: input.confidence || 0.5,\n  source: input.source || null\n};\n\n// Prepare request body for Firebase function\nconst requestBody = {\n  data: {\n    user_id: originalData.user_id,\n    type: originalData.type,\n    suggested_category: '' // Not needed at this stage\n  }\n};\n\n// Make HTTP request to Firebase function using N8N's HTTP helper\nconst FIREBASE_URL = 'https://us-central1-money-magnet-cf5a4.cloudfunctions.net/getUserCategoriesHttp';\n\ntry {\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: FIREBASE_URL,\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: requestBody,\n    json: true\n  });\n  \n  // Handle Firebase callable function response wrapper\n  const httpResponse = response;\n  const result = httpResponse.result || httpResponse;\n  \n  // Extract categories from response\n  const categories = result.categories || [];\n  \n  // Return all original fields plus categories\n  return {\n    ...originalData,\n    categories: categories\n  };\n} catch (error) {\n  // If request fails, return original data with empty categories\n  console.error('Error getting user categories:', error.message);\n  return {\n    ...originalData,\n    categories: []\n  };\n}"
      },
      "id": "get-categories",
      "name": "Get User Categories",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1050,
        500
      ]
    },
    {
      "parameters": {
        "jsCode": "// Pass through AI categorization results\n// AI Categorization node now returns category_id and category_name directly\n// So we just need to preserve all the data\nconst input = $input.item.json;\n\n// Return all fields as-is (AI Categorization already matched to user categories)\nreturn {\n  user_id: input.user_id || '',\n  type: input.type || 'expense',\n  description: input.description || '',\n  merchant: input.merchant || '',\n  suggested_category: input.suggested_category || null,\n  category_id: input.category_id || null,\n  category_name: input.category_name || null,\n  confidence: input.confidence || 0.5,\n  source: input.source || 'ai',\n  match_score: input.match_score || 0,\n  matched_keyword: input.matched_keyword || null\n};"
      },
      "id": "match-category",
      "name": "Match Category",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1450,
        400
      ]
    },
    {
      "parameters": {
        "mode": "append",
        "options": {}
      },
      "id": "merge-results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        1650,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({\n  category_id: $json.category_id || null,\n  category_name: $json.category_name || null,\n  confidence: $json.confidence || 0.8,\n  source: $json.source || 'ai',\n  category_source: $json.source === 'ai' ? 'ai' : ($json.source === 'learned' ? 'learned' : null)\n}) }}"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1850,
        300
      ]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Normalize Pattern",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Pattern": {
      "main": [
        [
          {
            "node": "Check Learned Mapping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Learned Mapping": {
      "main": [
        [
          {
            "node": "Mapping Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mapping Found?": {
      "main": [
        [
          {
            "node": "Use Learned Category",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User Categories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Categories": {
      "main": [
        [
          {
            "node": "AI Categorization",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Learned Category": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Categorization": {
      "main": [
        [
          {
            "node": "Match Category",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match Category": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T00:00:00.000Z",
  "versionId": "1"
}