{
  "name": "Categorize Transactions Batch",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "categorize-transactions-batch",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-batch",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "categorize-transactions-batch"
    },
    {
      "parameters": {
        "jsCode": "// Split batch into individual transactions\n// Handle webhook data - it may be in body or at root level\nconst webhookData = $input.item.json.body || $input.item.json;\nconst transactions = webhookData.transactions || [];\n\nif (!Array.isArray(transactions) || transactions.length === 0) {\n  return [];\n}\n\n// Return each transaction as a separate item\nreturn transactions.map(tx => ({\n  transaction_id: tx.transaction_id || tx.id || '',\n  user_id: tx.user_id || '',\n  description: tx.description || '',\n  merchant: tx.merchant || '',\n  type: tx.type || 'expense',\n  amount: tx.amount || 0,\n  date: tx.date || ''\n}));"
      },
      "id": "split-batch",
      "name": "Split Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Normalize merchant/description for matching\nconst input = $input.item.json;\nconst description = input.description || '';\nconst merchant = input.merchant || '';\nconst user_id = input.user_id || '';\nconst type = input.type || '';\nconst amount = input.amount || 0;\nconst date = input.date || '';\nconst transaction_id = input.transaction_id || '';\n\n// Normalize: uppercase, remove special chars\nconst normalize = (str) => {\n  if (!str) return '';\n  return str\n    .toUpperCase()\n    .replace(/[^A-Z0-9\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst normalizedMerchant = normalize(merchant);\nconst normalizedDescription = normalize(description);\nconst pattern = normalizedMerchant || normalizedDescription;\n\n// Return all fields needed for downstream nodes\nreturn {\n  user_id: user_id,\n  description: description,\n  merchant: merchant,\n  type: type,\n  amount: amount,\n  date: date,\n  transaction_id: transaction_id,\n  pattern: pattern,\n  normalized_merchant: normalizedMerchant,\n  normalized_description: normalizedDescription\n};"
      },
      "id": "normalize-pattern",
      "name": "Normalize Pattern",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Check Learned Mapping - Make HTTP request while preserving input\nconst input = $input.item.json;\n\n// Preserve all original input fields\nconst originalData = {\n  user_id: input.user_id || '',\n  description: input.description || '',\n  merchant: input.merchant || '',\n  type: input.type || '',\n  amount: input.amount || 0,\n  date: input.date || '',\n  transaction_id: input.transaction_id || '',\n  pattern: input.pattern || '',\n  normalized_merchant: input.normalized_merchant || '',\n  normalized_description: input.normalized_description || ''\n};\n\n// Prepare request body for Firebase function\nconst requestBody = {\n  data: {\n    user_id: originalData.user_id,\n    pattern: originalData.pattern,\n    transaction_type: originalData.type\n  }\n};\n\n// Make HTTP request to Firebase function using N8N's HTTP helper\nconst FIREBASE_URL = 'https://us-central1-money-magnet-cf5a4.cloudfunctions.net/checkCategoryMappingHttp';\n\ntry {\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: FIREBASE_URL,\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: requestBody,\n    json: true\n  });\n  \n  // Handle Firebase callable function response wrapper\n  const httpResponse = response;\n  const result = httpResponse.result || httpResponse;\n  \n  // Extract mapping data\n  const mapping_found = result.mapping_found || false;\n  const category_id = result.category_id || null;\n  const category_name = result.category_name || null;\n  const confidence = result.confidence || 1.0;\n  \n  // Return all original fields plus mapping response\n  return {\n    ...originalData,\n    mapping_found: mapping_found,\n    category_id: category_id,\n    category_name: category_name,\n    confidence: confidence,\n    source: mapping_found ? 'learned' : null\n  };\n} catch (error) {\n  // If request fails, return original data with mapping_found = false\n  console.error('Error checking category mapping:', error.message);\n  return {\n    ...originalData,\n    mapping_found: false,\n    category_id: null,\n    category_name: null,\n    confidence: 0.5,\n    source: null\n  };\n}"
      },
      "id": "check-mapping",
      "name": "Check Learned Mapping",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "mapping-found",
              "leftValue": "={{ $json.mapping_found }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-mapping",
      "name": "Mapping Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "transaction-id",
              "name": "transaction_id",
              "value": "={{ $json.transaction_id || $json.id }}",
              "type": "string"
            },
            {
              "id": "description",
              "name": "description",
              "value": "={{ $json.description || '' }}",
              "type": "string"
            },
            {
              "id": "merchant",
              "name": "merchant",
              "value": "={{ $json.merchant || '' }}",
              "type": "string"
            },
            {
              "id": "category-id",
              "name": "category_id",
              "value": "={{ $json.category_id }}",
              "type": "string"
            },
            {
              "id": "category-name",
              "name": "category_name",
              "value": "={{ $json.category_name }}",
              "type": "string"
            },
            {
              "id": "confidence",
              "name": "confidence",
              "value": "={{ $json.confidence || 1.0 }}",
              "type": "number"
            },
            {
              "id": "source",
              "name": "source",
              "value": "learned",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "use-learned",
      "name": "Use Learned Category",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.2,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Enhanced similarity-based categorization with improved matching\n// Preserve all input data\nconst input = $input.item.json;\nconst description = input.description || '';\nconst merchant = input.merchant || '';\nconst normalizedMerchant = input.normalized_merchant || '';\nconst normalizedDescription = input.normalized_description || '';\nconst user_id = input.user_id || '';\nconst type = input.type || 'expense';\n\n// Use normalized text for better matching (already uppercase, no special chars)\n// Fall back to lowercase original if normalized not available\nconst text = ((normalizedMerchant || merchant.toLowerCase()) + ' ' + (normalizedDescription || description.toLowerCase())).trim();\n\n// Normalize function for keywords (remove special chars, lowercase)\nfunction normalizeKeyword(str) {\n  return str.toLowerCase().replace(/[^a-z0-9\\s]/g, '').replace(/\\s+/g, ' ').trim();\n}\n\n// Calculate similarity between two strings (Levenshtein-based)\n// Only returns high scores for meaningful matches\nfunction similarity(str1, str2) {\n  const longer = str1.length > str2.length ? str1 : str2;\n  const shorter = str1.length > str2.length ? str2 : str1;\n  if (longer.length === 0) return 0;\n  if (shorter.length < 3) return 0; // Ignore very short matches\n  \n  // Check for exact match (normalized)\n  if (longer === shorter) return 1.0;\n  \n  // Check for meaningful substring match (shorter must be at least 4 chars)\n  if (shorter.length >= 4 && longer.includes(shorter)) return 0.9;\n  if (longer.length >= 4 && shorter.includes(longer)) return 0.9;\n  \n  // Calculate edit distance for similarity\n  const editDistance = levenshteinDistance(longer, shorter);\n  const similarityScore = (longer.length - editDistance) / longer.length;\n  \n  // Only return similarity if it's meaningful (>= 0.6)\n  return similarityScore >= 0.6 ? similarityScore : 0;\n}\n\n// Levenshtein distance calculation\nfunction levenshteinDistance(str1, str2) {\n  const matrix = [];\n  for (let i = 0; i <= str2.length; i++) {\n    matrix[i] = [i];\n  }\n  for (let j = 0; j <= str1.length; j++) {\n    matrix[0][j] = j;\n  }\n  for (let i = 1; i <= str2.length; i++) {\n    for (let j = 1; j <= str1.length; j++) {\n      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1,\n          matrix[i][j - 1] + 1,\n          matrix[i - 1][j] + 1\n        );\n      }\n    }\n  }\n  return matrix[str2.length][str1.length];\n}\n\n// Find best matching keyword with similarity score\n// Prioritizes exact matches, then substring, then similarity\nfunction findBestMatch(text, keywords) {\n  let bestMatch = null;\n  let bestScore = 0;\n  \n  // Normalize text for comparison\n  const textNormalized = normalizeKeyword(text);\n  const textWords = textNormalized.split(/\\s+/).filter(w => w.length >= 3);\n  \n  for (const keyword of keywords) {\n    const keywordNormalized = normalizeKeyword(keyword);\n    \n    // Priority 1: Exact match (normalized)\n    if (textNormalized === keywordNormalized) {\n      return { keyword, score: 1.0 };\n    }\n    \n    // Priority 2: Exact substring match (keyword appears in text)\n    if (textNormalized.includes(keywordNormalized) && keywordNormalized.length >= 4) {\n      return { keyword, score: 1.0 };\n    }\n    \n    // Priority 3: Word-by-word exact match\n    for (const word of textWords) {\n      if (word === keywordNormalized) {\n        return { keyword, score: 1.0 };\n      }\n      if (keywordNormalized.includes(word) && word.length >= 4) {\n        return { keyword, score: 0.95 };\n      }\n    }\n    \n    // Priority 4: Similarity matching (only if no exact match found)\n    if (bestScore < 0.95) {\n      // Check word-by-word similarity\n      for (const word of textWords) {\n        const sim = similarity(word, keywordNormalized);\n        if (sim > bestScore && sim >= 0.6) { // Minimum threshold\n          bestScore = sim;\n          bestMatch = keyword;\n        }\n      }\n      \n      // Check full text similarity\n      const fullSim = similarity(textNormalized, keywordNormalized);\n      if (fullSim > bestScore && fullSim >= 0.6) { // Minimum threshold\n        bestScore = fullSim;\n        bestMatch = keyword;\n      }\n    }\n  }\n  \n  // Only return if we have a meaningful match (score >= 0.6)\n  return (bestMatch && bestScore >= 0.6) ? { keyword: bestMatch, score: bestScore } : null;\n}\n\n// Expanded category keyword mapping with many more examples\nconst categories = {\n  'groceries': [\n    'walmart', 'target', 'kroger', 'safeway', 'whole foods', 'wegmans', 'publix', 'hannaford',\n    'stop & shop', 'giant', 'food lion', 'aldi', 'lidl', 'trader joe', 'costco', 'sam club',\n    'grocery', 'supermarket', 'food store', 'market', 'food market', 'grocery store',\n    'super center', 'supercenter', 'food city', 'harris teeter', 'king soopers', 'ralphs',\n    'vons', 'albertsons', 'fred meyer', 'qfc', 'smiths', 'frys', 'jewel osco', 'acme'\n  ],\n  'restaurants': [\n    'restaurant', 'mcdonald', 'burger king', 'wendy', 'taco bell', 'kfc', 'pizza hut',\n    'domino', 'papa john', 'subway', 'chipotle', 'qdoba', 'moe', 'panera', 'starbucks',\n    'dunkin', 'dunkin donut', 'pizza', 'burger', 'taco', 'burrito', 'sandwich', 'dining',\n    'diner', 'cafe', 'bistro', 'grill', 'steakhouse', 'seafood', 'sushi', 'chinese',\n    'italian', 'mexican', 'thai', 'indian', 'japanese', 'korean', 'vietnamese', 'mediterranean',\n    'olive garden', 'red lobster', 'outback', 'applebees', 'chilis', 'buffalo wild wing',\n    'texas roadhouse', 'longhorn', 'red robin', 'five guys', 'shake shack', 'in-n-out',\n    'whataburger', 'culvers', 'arby', 'jack in the box', 'white castle', 'del taco',\n    'panda express', 'pf chang', 'cheesecake factory', 'ihop', 'denny', 'waffle house'\n  ],\n  'coffee': [\n    'starbucks', 'dunkin', 'dunkin donut', 'coffee', 'cafe', 'espresso', 'latte', 'cappuccino',\n    'peets', 'caribou', 'tim horton', 'costa', 'nero', 'blue bottle', 'intelligentsia',\n    'philz', 'coffee bean', 'the coffee bean', 'biggby', 'dutch bros', 'black rock',\n    'the human bean', 'coffee shop', 'coffeehouse', 'cafÃ©', 'barista'\n  ],\n  'gas': [\n    'shell', 'exxon', 'chevron', 'bp', 'mobil', 'texaco', 'valero', 'citgo', 'sunoco',\n    'marathon', 'phillips 66', 'conoco', '76', 'arco', 'speedway', 'casey', 'kum & go',\n    'quik trip', 'qt', 'sheet', 'wa wa', 'race trac', 'pilot', 'flying j', 'love',\n    'gas station', 'fuel', 'gasoline', 'petrol', 'filling station', 'service station',\n    'truck stop', 'fuel stop'\n  ],\n  'utilities': [\n    'electric', 'electricity', 'power', 'energy', 'water', 'sewer', 'trash', 'garbage',\n    'waste', 'utility', 'utilities', 'gas company', 'natural gas', 'propane', 'heating',\n    'cooling', 'hvac', 'internet', 'broadband', 'wifi', 'cable', 'tv', 'television',\n    'phone', 'telephone', 'landline', 'cell phone', 'mobile', 'verizon', 'at&t', 't-mobile',\n    'sprint', 'comcast', 'xfinity', 'spectrum', 'cox', 'directv', 'dish', 'duke energy',\n    'southern california edison', 'pg&e', 'con edison', 'national grid'\n  ],\n  'rent': [\n    'rent', 'apartment', 'housing', 'lease', 'rental', 'landlord', 'property management',\n    'apartment complex', 'condo', 'condominium', 'townhouse', 'duplex', 'house', 'home',\n    'residence', 'dwelling', 'lodging', 'accommodation', 'tenant', 'lessee'\n  ],\n  'transportation': [\n    'uber', 'lyft', 'taxi', 'cab', 'rideshare', 'ride share', 'metro', 'subway', 'transit',\n    'bus', 'train', 'rail', 'railway', 'amtrak', 'greyhound', 'airport shuttle', 'shuttle',\n    'parking', 'parking meter', 'parking garage', 'valet', 'toll', 'toll road', 'ez pass',\n    'fastrak', 'sunpass', 'tollway', 'bridge toll', 'ferry', 'boat', 'boat ride',\n    'bike share', 'lime', 'bird', 'scooter', 'car rental', 'hertz', 'avis', 'enterprise',\n    'national', 'budget', 'alamo', 'europcar', 'sixt'\n  ],\n  'shopping': [\n    'amazon', 'ebay', 'etsy', 'walmart', 'target', 'costco', 'best buy', 'home depot',\n    'lowes', 'macy', 'nordstrom', 'kohl', 'jcp', 'jcpenney', 'sears', 'old navy',\n    'gap', 'banana republic', 'h&m', 'zara', 'forever 21', 'ulta', 'sephora',\n    'bath & body works', 'victoria secret', 'lululemon', 'nike', 'adidas', 'under armour',\n    'store', 'retail', 'shop', 'shopping', 'mall', 'outlet', 'marketplace', 'online',\n    'ecommerce', 'e-commerce', 'marketplace', 'auction', 'bid', 'purchase', 'buy'\n  ],\n  'entertainment': [\n    'netflix', 'spotify', 'apple music', 'youtube', 'youtube premium', 'hulu', 'disney',\n    'disney plus', 'disney+', 'hbo', 'hbo max', 'paramount', 'peacock', 'amazon prime',\n    'movie', 'theater', 'cinema', 'amc', 'regal', 'cinemark', 'concert', 'show', 'ticket',\n    'ticketmaster', 'stubhub', 'event', 'festival', 'music', 'song', 'album', 'game',\n    'video game', 'playstation', 'xbox', 'nintendo', 'steam', 'epic games', 'twitch',\n    'streaming', 'subscription', 'membership', 'club', 'arcade', 'bowling', 'mini golf',\n    'laser tag', 'escape room', 'comedy club', 'nightclub', 'bar', 'pub', 'lounge'\n  ],\n  'healthcare': [\n    'pharmacy', 'cvs', 'walgreens', 'rite aid', 'walmart pharmacy', 'target pharmacy',\n    'doctor', 'physician', 'dentist', 'orthodontist', 'optometrist', 'ophthalmologist',\n    'hospital', 'clinic', 'medical', 'health', 'healthcare', 'health care', 'urgent care',\n    'emergency room', 'er', 'surgery', 'procedure', 'lab', 'laboratory', 'x-ray', 'xray',\n    'mri', 'ct scan', 'ultrasound', 'prescription', 'medication', 'medicine', 'drug',\n    'insurance', 'copay', 'deductible', 'medical bill', 'hospital bill', 'dental',\n    'vision', 'eye exam', 'glasses', 'contacts', 'hearing aid', 'physical therapy',\n    'chiropractor', 'massage', 'therapy', 'counseling', 'psychiatrist', 'psychologist'\n  ],\n  'subscriptions': [\n    'subscription', 'membership', 'monthly', 'annual', 'yearly', 'recurring', 'auto renew',\n    'netflix', 'spotify', 'apple music', 'youtube premium', 'hulu', 'disney', 'hbo',\n    'amazon prime', 'adobe', 'microsoft', 'office 365', 'dropbox', 'icloud', 'google one',\n    'cloud storage', 'software', 'saas', 'service', 'premium', 'pro', 'plus', 'basic',\n    'tier', 'plan', 'billing', 'renewal', 'auto-pay', 'autopay'\n  ],\n  'insurance': [\n    'insurance', 'auto insurance', 'car insurance', 'home insurance', 'homeowner',\n    'renters insurance', 'life insurance', 'health insurance', 'dental insurance',\n    'vision insurance', 'disability', 'geico', 'state farm', 'allstate', 'progressive',\n    'farmers', 'liberty mutual', 'usaa', 'nationwide', 'travelers', 'american family',\n    'premium', 'policy', 'coverage', 'claim', 'deductible', 'copay', 'copayment'\n  ],\n  'education': [\n    'tuition', 'school', 'university', 'college', 'textbook', 'book', 'course', 'class',\n    'education', 'learning', 'training', 'workshop', 'seminar', 'conference', 'certification',\n    'student loan', 'loan payment', 'financial aid', 'scholarship', 'grant', 'fee',\n    'registration', 'enrollment', 'campus', 'dorm', 'housing', 'meal plan', 'cafeteria'\n  ],\n  'personal care': [\n    'haircut', 'hair', 'salon', 'barber', 'spa', 'massage', 'facial', 'manicure',\n    'pedicure', 'nail', 'wax', 'tanning', 'gym', 'fitness', 'workout', 'yoga', 'pilates',\n    'personal trainer', 'crossfit', 'planet fitness', '24 hour fitness', 'la fitness',\n    'equinox', 'orange theory', 'soulcycle', 'peloton', 'beauty', 'cosmetic', 'makeup',\n    'skincare', 'toiletries', 'shampoo', 'soap', 'toothpaste', 'deodorant'\n  ],\n  'home & garden': [\n    'home depot', 'lowes', 'harbor freight', 'ace hardware', 'true value', 'menards',\n    'home improvement', 'furniture', 'ikea', 'wayfair', 'overstock', 'bed bath',\n    'crate & barrel', 'pottery barn', 'west elm', 'homegoods', 'tj maxx', 'marshalls',\n    'garden', 'landscaping', 'lawn', 'yard', 'plant', 'seed', 'fertilizer', 'tool',\n    'appliance', 'refrigerator', 'washer', 'dryer', 'oven', 'dishwasher', 'microwave'\n  ],\n  'automotive': [\n    'car', 'automotive', 'auto', 'vehicle', 'tire', 'oil change', 'mechanic', 'repair',\n    'maintenance', 'service', 'jiffy lube', 'valvoline', 'firestone', 'goodyear',\n    'bridgestone', 'michelin', 'auto zone', 'oreilly', 'advance auto', 'napa', 'pep boys',\n    'car wash', 'detailing', 'registration', 'dmv', 'license', 'inspection', 'emissions'\n  ],\n  'travel': [\n    'hotel', 'motel', 'airbnb', 'booking', 'expedia', 'priceline', 'kayak', 'orbitz',\n    'travelocity', 'airline', 'flight', 'airport', 'delta', 'united', 'american', 'southwest',\n    'jetblue', 'alaska', 'spirit', 'frontier', 'luggage', 'suitcase', 'travel', 'trip',\n    'vacation', 'cruise', 'resort', 'all inclusive', 'tour', 'excursion', 'visa', 'passport'\n  ],\n  'charity & donations': [\n    'donation', 'charity', 'nonprofit', 'non-profit', 'ngo', 'contribution', 'give',\n    'red cross', 'unicef', 'salvation army', 'goodwill', 'habitat for humanity',\n    'world vision', 'doctors without borders', 'st jude', 'make a wish', 'toys for tots',\n    'go fund me', 'gofundme', 'kickstarter', 'indiegogo', 'patreon', 'tip', 'gratuity'\n  ],\n  'fees & charges': [\n    'fee', 'charge', 'service fee', 'transaction fee', 'atm fee', 'overdraft', 'nsf',\n    'late fee', 'penalty', 'interest', 'finance charge', 'annual fee', 'monthly fee',\n    'maintenance fee', 'account fee', 'wire transfer', 'foreign transaction', 'currency',\n    'conversion', 'convenience fee', 'processing fee', 'admin fee', 'setup fee'\n  ],\n  'income': [\n    'salary', 'paycheck', 'wage', 'income', 'pay', 'payment', 'deposit', 'direct deposit',\n    'payroll', 'bonus', 'commission', 'refund', 'reimbursement', 'rebate', 'cashback',\n    'cash back', 'reward', 'points', 'dividend', 'interest income', 'investment return',\n    'capital gain', 'gift', 'transfer in', 'venmo', 'paypal', 'zelle', 'cash app'\n  ]\n};\n\nlet suggestedCategory = null;\nlet bestMatch = null;\nlet bestScore = 0;\n\n// Find best matching category using similarity\nfor (const [cat, keywords] of Object.entries(categories)) {\n  const match = findBestMatch(text, keywords);\n  if (match && match.score > bestScore) {\n    bestScore = match.score;\n    bestMatch = match;\n    suggestedCategory = cat;\n  }\n}\n\n// Set confidence based on similarity score\nlet confidence = 0.6;\nif (bestScore >= 0.9) {\n  confidence = 0.95; // Very high confidence for exact/close matches\n} else if (bestScore >= 0.7) {\n  confidence = 0.85; // High confidence for good matches\n} else if (bestScore >= 0.5) {\n  confidence = 0.75; // Medium confidence for partial matches\n} else if (bestScore > 0) {\n  confidence = 0.65; // Low confidence for weak matches\n}\n\n// Return all original fields plus AI categorization results\nreturn {\n  ...input,\n  user_id: user_id,\n  type: type,\n  description: description,\n  merchant: merchant,\n  suggested_category: suggestedCategory,\n  confidence: confidence,\n  source: 'ai',\n  match_score: bestScore,\n  matched_keyword: bestMatch ? bestMatch.keyword : null\n};"
      },
      "id": "ai-categorize",
      "name": "AI Categorization",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Get User Categories - Make HTTP request while preserving input\nconst input = $input.item.json;\n\n// Preserve all original input fields\nconst originalData = {\n  user_id: input.user_id || '',\n  description: input.description || '',\n  merchant: input.merchant || '',\n  type: input.type || 'expense',\n  amount: input.amount || 0,\n  date: input.date || '',\n  transaction_id: input.transaction_id || '',\n  pattern: input.pattern || '',\n  normalized_merchant: input.normalized_merchant || '',\n  normalized_description: input.normalized_description || '',\n  suggested_category: input.suggested_category || null,\n  confidence: input.confidence || 0.5,\n  source: input.source || 'ai',\n  match_score: input.match_score || 0,\n  matched_keyword: input.matched_keyword || null\n};\n\n// Prepare request body for Firebase function\nconst requestBody = {\n  data: {\n    user_id: originalData.user_id,\n    type: originalData.type,\n    suggested_category: originalData.suggested_category || ''\n  }\n};\n\n// Make HTTP request to Firebase function using N8N's HTTP helper\nconst FIREBASE_URL = 'https://us-central1-money-magnet-cf5a4.cloudfunctions.net/getUserCategoriesHttp';\n\ntry {\n  const response = await this.helpers.httpRequest({\n    method: 'POST',\n    url: FIREBASE_URL,\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: requestBody,\n    json: true\n  });\n  \n  // Handle Firebase callable function response wrapper\n  const httpResponse = response;\n  const result = httpResponse.result || httpResponse;\n  \n  // Extract categories and suggested_category from response\n  const categories = result.categories || [];\n  const suggested_category = result.suggested_category || originalData.suggested_category;\n  \n  // Return all original fields plus categories response\n  return {\n    ...originalData,\n    categories: categories,\n    suggested_category: suggested_category\n  };\n} catch (error) {\n  // If request fails, return original data with empty categories\n  console.error('Error getting user categories:', error.message);\n  return {\n    ...originalData,\n    categories: [],\n    suggested_category: originalData.suggested_category\n  };\n}"
      },
      "id": "get-categories",
      "name": "Get User Categories",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Preserve all input data\nconst input = $input.item.json;\n\n// Get categories and suggested_category from input (preserved by Get User Categories Code node)\nconst userCategories = input.categories || [];\n\n// Get suggested_category from input (preserved by Get User Categories Code node)\nlet suggested = input.suggested_category || null;\n\n// Strip '=' prefix if present (N8N expression evaluation issue)\nif (suggested && typeof suggested === 'string' && suggested.startsWith('=')) {\n  suggested = suggested.substring(1);\n}\n\n// Preserve original fields from AI Categorization (all preserved by Get User Categories Code node)\nconst user_id = input.user_id || '';\nconst type = input.type || 'expense';\nconst description = input.description || '';\nconst merchant = input.merchant || '';\nconst confidence = input.confidence || 0.5;\nconst match_score = input.match_score || 0;\nconst matched_keyword = input.matched_keyword || null;\nconst transaction_id = input.transaction_id || '';\n\nif (!suggested) {\n  return {\n    transaction_id: transaction_id,\n    user_id: user_id,\n    type: type,\n    description: description,\n    merchant: merchant,\n    suggested_category: null,\n    category_id: null,\n    category_name: null,\n    confidence: confidence,\n    source: input.source || 'ai',\n    match_score: match_score,\n    matched_keyword: matched_keyword\n  };\n}\n\n// Normalize suggested category for matching (lowercase, trim, handle variations)\nconst suggestedNormalized = suggested.toLowerCase().trim();\n\n// Find matching category by name (case-insensitive, handles variations)\nconst match = userCategories.find(cat => {\n  const catName = (cat.name || '').toLowerCase().trim();\n  \n  // Exact match (normalized)\n  if (catName === suggestedNormalized) return true;\n  \n  // Substring match (either direction)\n  if (catName.includes(suggestedNormalized) || suggestedNormalized.includes(catName)) return true;\n  \n  // Handle plural/singular variations (e.g., \"restaurant\" vs \"restaurants\")\n  const catNameSingular = catName.replace(/s$/, '');\n  const suggestedSingular = suggestedNormalized.replace(/s$/, '');\n  if (catNameSingular === suggestedSingular && catNameSingular.length > 3) return true;\n  \n  return false;\n});\n\nreturn {\n  transaction_id: transaction_id,\n  user_id: user_id,\n  type: type,\n  description: description,\n  merchant: merchant,\n  suggested_category: suggested, // Return cleaned version (without = prefix)\n  category_id: match ? match.id : null,\n  category_name: match ? match.name : null,\n  confidence: match ? Math.max(confidence, 0.8) : confidence,\n  source: input.source || 'ai',\n  match_score: match_score,\n  matched_keyword: matched_keyword\n};"
      },
      "id": "match-category",
      "name": "Match Category",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 400]
    },
    {
      "parameters": {
        "mode": "append",
        "options": {}
      },
      "id": "merge-results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [2050, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Collect ALL items from ALL execution runs\n// This handles cases where N8N splits execution into multiple runs\nconst allItems = $input.all();\n\nconsole.log('ðŸ“Š [N8N] Total items collected from current run:', allItems.length);\n\n// If execution was split, we need to collect from previous runs too\n// Note: This is a workaround - ideally N8N shouldn't split, but if it does,\n// we'll try to get all items. The webhook will respond with what we have.\n\n// Map all items to result format\nconst results = allItems.map(item => {\n  const json = item.json || {};\n  \n  // Ensure category_name is always included if category_id exists\n  let categoryName = json.category_name || null;\n  if (!categoryName && json.category_id) {\n    // Try to extract from suggested_category or other fields\n    categoryName = json.suggested_category || null;\n  }\n  \n  return {\n    transaction_id: json.transaction_id || json.id || null,\n    description: json.description || '',\n    merchant: json.merchant || '',\n    category_id: json.category_id || null,\n    category_name: categoryName,\n    suggested_category: json.suggested_category || null,\n    confidence: json.confidence || 0.8,\n    source: json.source || 'ai',\n    category_source: json.source === 'ai' ? 'ai' : (json.source === 'learned' ? 'learned' : null),\n    match_score: json.match_score || 0,\n    matched_keyword: json.matched_keyword || null\n  };\n});\n\nconsole.log('âœ… [N8N] Prepared', results.length, 'results for response');\nconsole.log('ðŸ“‹ [N8N] Sample results:', results.slice(0, 3).map(r => ({ id: r.transaction_id, cat_id: r.category_id, cat_name: r.category_name })));\n\n// Return response object\nreturn {\n  success: true,\n  count: results.length,\n  results: results\n};"
      },
      "id": "prepare-response",
      "name": "Prepare Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2450, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [[{"node": "Split Batch", "type": "main", "index": 0}]]
    },
    "Split Batch": {
      "main": [[{"node": "Normalize Pattern", "type": "main", "index": 0}]]
    },
    "Normalize Pattern": {
      "main": [[{"node": "Check Learned Mapping", "type": "main", "index": 0}]]
    },
    "Check Learned Mapping": {
      "main": [[{"node": "Mapping Found?", "type": "main", "index": 0}]]
    },
    "Mapping Found?": {
      "main": [
        [{"node": "Use Learned Category", "type": "main", "index": 0}],
        [{"node": "AI Categorization", "type": "main", "index": 0}]
      ]
    },
    "Use Learned Category": {
      "main": [[{"node": "Merge Results", "type": "main", "index": 0}]]
    },
    "AI Categorization": {
      "main": [[{"node": "Get User Categories", "type": "main", "index": 0}]]
    },
    "Get User Categories": {
      "main": [[{"node": "Match Category", "type": "main", "index": 0}]]
    },
    "Match Category": {
      "main": [[{"node": "Merge Results", "type": "main", "index": 0}]]
    },
    "Merge Results": {
      "main": [[{"node": "Prepare Response", "type": "main", "index": 0}]]
    },
    "Prepare Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": false,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-15T00:00:00.000Z",
  "versionId": "1"
}

